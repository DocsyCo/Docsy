{"hierarchy":{"paths":[["doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/argumentparser\/declaringarguments"]}],"metadata":{"role":"article","title":"Declaring Arguments, Options, and Flags","modules":[{"name":"ArgumentParser"}],"roleHeading":"Article"},"abstract":[{"type":"text","text":"Use the "},{"code":"@Argument","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" property wrappers to declare the command-line interface for your command."}],"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Argument","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Option","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Flag","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments"],"anchor":"Arguments-Options-and-Flags","title":"Arguments, Options, and Flags"}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","text":"Overview","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"When creating commands, you can define three primary kinds of command-line inputs:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Arguments"}]},{"type":"text","text":" are values given by a user and are read in order from first to last (see "},{"type":"reference","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Argument","isActive":true},{"text":"). For example, this command is called with three file names as arguments:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["% example file1.swift file2.swift file3.swift"]}]},{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Options","type":"text"}]},{"text":" are named key-value pairs. Keys start with one or two dashes (","type":"text"},{"code":"-","type":"codeVoice"},{"type":"text","text":" or "},{"code":"--","type":"codeVoice"},{"text":"), and a user can separate the key and value with an equal sign (","type":"text"},{"code":"=","type":"codeVoice"},{"type":"text","text":") or a space (see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Option"},{"type":"text","text":"). This command is called with two options:"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["% example --count=5 --index 2"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Flags"}]},{"text":" are like options, but without a paired value. Instead, their presence indicates a particular value (see ","type":"text"},{"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Flag","isActive":true,"type":"reference"},{"type":"text","text":"). This command is called with two flags:"}]},{"type":"codeListing","code":["% example --verbose --strip-whitespace"],"syntax":null}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"The three preceding examples could be calls of this "},{"code":"Example","type":"codeVoice"},{"text":" command:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Argument var files: [String] = []","    @Option var count: Int?","    @Option var index = 0","    @Flag var verbose = false","    @Flag var stripWhitespace = false","}"],"syntax":"swift"},{"inlineContent":[{"text":"This example shows how ","type":"text"},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" provides defaults that speed up your initial development process:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Option and flag names are derived from the names of your command’s properties.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"What kinds of inputs are valid, and whether arguments are required, is based on your properties’ types and default values."}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"In this example, all of the properties have default values (optional properties default to ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":")."}]},{"inlineContent":[{"type":"text","text":"Users must provide values for all properties with no implicit or specified default. For example, this command would require one integer argument and a string with the key "},{"type":"codeVoice","code":"--user-name"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Example: ParsableCommand {","    @Option var userName: String","    @Argument var value: Int","}"]},{"inlineContent":[{"type":"text","text":"When called without both values, the command exits with an error:"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["% example 5","Error: Missing '--user-name <user-name>'","Usage: example --user-name <user-name> <value>","  See 'example --help' for more information.","% example --user-name kjohnson","Error: Missing '<value>'","Usage: example --user-name <user-name> <value>","  See 'example --help' for more information."]},{"type":"paragraph","inlineContent":[{"text":"When providing a default value for an array property, any user-supplied values replace the entire default.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Lucky: ParsableCommand {","    @Argument var numbers = [7, 14, 21]","","    mutating func run() throws {","        print(\"\"\"","        Your lucky numbers are:","        \\(numbers.map(String.init).joined(separator: \" \"))","        \"\"\")","    }","}"]},{"type":"codeListing","syntax":null,"code":["% lucky ","Your lucky numbers are:","7 14 21","% lucky 1 2 3","Your lucky numbers are:","1 2 3"]},{"anchor":"Customizing-option-and-flag-names","level":2,"text":"Customizing option and flag names","type":"heading"},{"inlineContent":[{"text":"By default, options and flags derive the name that you use on the command line from the name of the property, such as ","type":"text"},{"code":"--count","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"--index"},{"type":"text","text":". Camel-case names are converted to lowercase with hyphen-separated words, like "},{"type":"codeVoice","code":"--strip-whitespace"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can override this default by specifying one or more name specifications in the "},{"code":"@Option","type":"codeVoice"},{"type":"text","text":" or "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" initializers. This command demonstrates the four name specifications:"}],"type":"paragraph"},{"syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag(name: .long)  \/\/ Same as the default","    var stripWhitespace = false","","    @Flag(name: .short)","    var verbose = false","","    @Option(name: .customLong(\"count\"))","    var iterationCount: Int","","    @Option(name: [.customShort(\"I\"), .long])","    var inputFile: String","}"],"type":"codeListing"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Specifying ","type":"text"},{"type":"codeVoice","code":".long"},{"text":" or ","type":"text"},{"code":".short","type":"codeVoice"},{"text":" uses the property’s name as the source of the command-line name. Long names use the whole name, prefixed by two dashes, while short names are a single character prefixed by a single dash. In this example, the ","type":"text"},{"code":"stripWhitespace","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" flags are specified in this way:"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["% example --strip-whitespace -v"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Specifying "},{"type":"codeVoice","code":".customLong(_:)"},{"type":"text","text":" or "},{"type":"codeVoice","code":".customShort(_:)"},{"type":"text","text":" uses the given string or character as the long or short name for the property."}]},{"code":["% example --count 10 -I file1.swift"],"type":"codeListing","syntax":null}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use array literal syntax to specify multiple names. The "},{"type":"codeVoice","code":"inputFile"},{"text":" property can alternatively be given with the default long name:","type":"text"}]},{"type":"codeListing","code":["% example --input-file file1.swift"],"syntax":null}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Note:"}]},{"text":" You can also pass ","type":"text"},{"code":"withSingleDash: true","type":"codeVoice"},{"type":"text","text":" to "},{"code":".customLong","type":"codeVoice"},{"text":" to create a single-dash flag or option, such as ","type":"text"},{"type":"codeVoice","code":"-verbose"},{"type":"text","text":". Use this name specification only when necessary, such as when migrating a legacy command-line interface. Using long names with a single-dash prefix can lead to ambiguity with combined short names: it may not be obvious whether "},{"type":"codeVoice","code":"-file"},{"type":"text","text":" is a single option or the combination of the four short options "},{"type":"codeVoice","code":"-f"},{"text":", ","type":"text"},{"type":"codeVoice","code":"-i"},{"text":", ","type":"text"},{"code":"-l","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"-e"},{"text":".","type":"text"}]},{"text":"Parsing custom types","level":2,"type":"heading","anchor":"Parsing-custom-types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Arguments and options can be parsed from any type that conforms to the "},{"type":"reference","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument","isActive":true},{"type":"text","text":" protocol. Standard library integer and floating-point types, strings, and Booleans all conform to "},{"code":"ExpressibleByArgument","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can make your own custom types conform to "},{"type":"codeVoice","code":"ExpressibleByArgument"},{"type":"text","text":" by implementing "},{"isActive":true,"type":"reference","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument\/init(argument:)"},{"type":"text","text":":"}]},{"syntax":"swift","code":["struct Path: ExpressibleByArgument {","    var pathString: String","","    init?(argument: String) {","        self.pathString = argument","    }","}","","struct Example: ParsableCommand {","    @Argument var inputFile: Path","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The library provides a default implementation for ","type":"text"},{"type":"codeVoice","code":"RawRepresentable"},{"text":" types, like string-backed enumerations, so you only need to declare conformance.","type":"text"}]},{"code":["enum ReleaseMode: String, ExpressibleByArgument {","    case debug, release","}","","struct Example: ParsableCommand {","    @Option var mode: ReleaseMode","","    mutating func run() throws {","        print(mode)","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The user can provide the raw values on the command line, which are then converted to your custom type. Only valid values are allowed:","type":"text"}]},{"syntax":null,"code":["% example --mode release","release","% example --mode future","Error: The value 'future' is invalid for '--mode <mode>'"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To use a non-"},{"code":"ExpressibleByArgument","type":"codeVoice"},{"text":" type for an argument or option, you can instead provide a throwing ","type":"text"},{"code":"transform","type":"codeVoice"},{"text":" function that converts the parsed string to your desired type. This is a good idea for custom types that are more complex than a ","type":"text"},{"code":"RawRepresentable","type":"codeVoice"},{"type":"text","text":" type, or for types you don’t define yourself."}]},{"type":"codeListing","syntax":"swift","code":["enum Format {","    case text","    case other(String)","","    init(_ string: String) throws {","        if string == \"text\" {","            self = .text","        } else {","            self = .other(string)","        }","    }","}","","struct Example: ParsableCommand {","    @Argument(transform: Format.init)","    var format: Format","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Throw an error from the "},{"code":"transform","type":"codeVoice"},{"text":" function to indicate that the user provided an invalid value for that type. See ","type":"text"},{"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Validation","isActive":true,"type":"reference"},{"text":" for more about customizing ","type":"text"},{"code":"transform","type":"codeVoice"},{"text":" function errors.","type":"text"}]},{"type":"heading","level":2,"text":"Using flag inversions, enumerations, and counts","anchor":"Using-flag-inversions-enumerations-and-counts"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Flags are most frequently used for "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" properties. You can generate a "},{"type":"codeVoice","code":"true"},{"type":"text","text":"\/"},{"code":"false","type":"codeVoice"},{"text":" pair of flags by specifying a flag inversion:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag(inversion: .prefixedNo)","    var index = true","","    @Flag(inversion: .prefixedEnableDisable)","    var requiredElement: Bool","","    mutating func run() throws {","        print(index, requiredElement)","    }","}"]},{"inlineContent":[{"type":"text","text":"When declaring a flag with an inversion, set the default by specifying "},{"code":"true","type":"codeVoice"},{"type":"text","text":" or "},{"code":"false","type":"codeVoice"},{"type":"text","text":" as the property’s initial value. If you want to require that the user specify one of the two inversions, leave off the default value."}],"type":"paragraph"},{"inlineContent":[{"text":"In the ","type":"text"},{"type":"codeVoice","code":"Example"},{"type":"text","text":" command defined above, a flag is required for the "},{"type":"codeVoice","code":"requiredElement"},{"type":"text","text":" property. The specified prefixes are prepended to the long names for the flags:"}],"type":"paragraph"},{"syntax":null,"code":["% example --enable-required-element","true true","% example --no-index --disable-required-element","false false","% example --index","Error: Missing one of: '--enable-required-element', '--disable-required-element'"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"To create a flag with custom names for a Boolean value, to provide an exclusive choice between more than two names, or for collecting multiple values from a set of defined choices, define an enumeration that conforms to the ","type":"text"},{"type":"codeVoice","code":"EnumerableFlag"},{"type":"text","text":" protocol."}]},{"code":["enum CacheMethod: String, EnumerableFlag {","    case inMemoryCache","    case persistentCache","}","","enum Color: String, EnumerableFlag {","    case pink, purple, silver","}","","struct Example: ParsableCommand {","    @Flag var cacheMethod: CacheMethod","    @Flag var colors: [Color] = []","","    mutating func run() throws {","        print(cacheMethod)","        print(colors)","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The flag names in this case are drawn from the raw values — for information about customizing the names and help text, see the  "},{"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag","type":"reference","isActive":true},{"type":"text","text":" documentation."}],"type":"paragraph"},{"type":"codeListing","code":["% example --in-memory-cache --pink --silver",".inMemoryCache","[.pink, .silver]","% example","Error: Missing one of: '--in-memory-cache', '--persistent-cache'"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, when a flag is of type "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", the value is parsed as a count of the number of times that the flag is specified."}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag(name: .shortAndLong)","    var verbose: Int","","    mutating func run() throws {","        print(\"Verbosity level: \\(verbose)\")","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"In this example, ","type":"text"},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" defaults to zero, and counts the number of times that "},{"code":"-v","type":"codeVoice"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" is given."}]},{"syntax":null,"code":["% example --verbose","Verbosity level: 1","% example -vvvv","Verbosity level: 4"],"type":"codeListing"},{"level":2,"anchor":"Specifying-default-values","text":"Specifying default values","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"You can specify default values for almost all supported argument, option, and flag types using normal property initialization syntax:","type":"text"}]},{"syntax":"swift","code":["enum CustomFlag: String, EnumerableFlag {","    case foo, bar, baz","}","","struct Example: ParsableCommand {","    @Flag","    var booleanFlag = false","","    @Flag","    var arrayFlag: [CustomFlag] = [.foo, .baz]","","    @Option","    var singleOption = 0","","    @Option","    var arrayOption = [\"bar\", \"qux\"]","","    @Argument","    var singleArgument = \"quux\"","","    @Argument","    var arrayArgument = [\"quux\", \"quuz\"]","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This includes all of the variants of the argument types above (including "},{"type":"codeVoice","code":"@Option(transform: ...)"},{"type":"text","text":", etc.), with a few notable exceptions:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Optional"},{"type":"text","text":"-typed values (which default to "},{"type":"codeVoice","code":"nil"},{"text":" and for which a default would not make sense, as the value could never be ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Int"},{"type":"text","text":" flags (which are used for counting the number of times a flag is specified and therefore default to "},{"code":"0","type":"codeVoice"},{"type":"text","text":")"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a default is not specified, the user must provide a value for that argument\/option\/flag or will receive an error that the value is missing."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You must also always specify a default of "},{"type":"codeVoice","code":"false"},{"type":"text","text":" for a non-optional "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" flag, as in the example above. This makes the behavior consistent with both normal Swift properties (which either must be explicitly initialized or optional to initialize a "},{"type":"codeVoice","code":"struct"},{"text":"\/","type":"text"},{"type":"codeVoice","code":"class"},{"type":"text","text":" containing them) and the other property types."}]},{"anchor":"Specifying-a-parsing-strategy","type":"heading","text":"Specifying a parsing strategy","level":2},{"inlineContent":[{"type":"text","text":"When parsing a list of command-line inputs, "},{"type":"codeVoice","code":"ArgumentParser"},{"text":" distinguishes between dash-prefixed keys and un-prefixed values. When looking for the value for a key, only an un-prefixed value will be selected by default.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, this command defines a "},{"type":"codeVoice","code":"--verbose"},{"text":" flag, a ","type":"text"},{"type":"codeVoice","code":"--name"},{"type":"text","text":" option, and an optional "},{"type":"codeVoice","code":"file"},{"text":" argument:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    @Option var name: String","    @Argument var file: String?","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), name: \\(name), file: \\(file ?? \"none\")\")","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When calling this command, the value for "},{"type":"codeVoice","code":"--name"},{"type":"text","text":" must be given immediately after the key. If the "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag is placed in between, parsing fails with an error:"}]},{"type":"codeListing","code":["% example --verbose --name Tomás","Verbose: true, name: Tomás, file: none","% example --name --verbose Tomás","Error: Missing value for '--name <name>'","Usage: example [--verbose] --name <name> [<file>]","  See 'example --help' for more information."],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"Parsing options as arrays is similar — only adjacent key-value pairs are recognized by default.","type":"text"}]},{"text":"Alternative single-value parsing strategies","type":"heading","anchor":"Alternative-single-value-parsing-strategies","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can change this behavior by providing a different parsing strategy in the "},{"type":"codeVoice","code":"@Option"},{"text":" initializer. ","type":"text"},{"inlineContent":[{"type":"text","text":"Be careful when selecting any of the alternative parsing strategies"}],"type":"strong"},{"type":"text","text":" — they may lead your command-line tool to have unexpected behavior for users!"}]},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":".unconditional"},{"type":"text","text":" parsing strategy uses the immediate next input for the value of the option, even if it starts with a dash. If "},{"type":"codeVoice","code":"name"},{"type":"text","text":" were instead defined as "},{"type":"codeVoice","code":"@Option(parsing: .unconditional) var name: String"},{"text":", the second attempt would result in ","type":"text"},{"type":"codeVoice","code":"\"--verbose\""},{"type":"text","text":" being read as the value of "},{"type":"codeVoice","code":"name"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":null,"code":["% example --name --verbose Tomás","Verbose: false, name: --verbose, file: Tomás"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":".scanningForValue"},{"text":" strategy, on the other hand, looks ahead in the list of command-line inputs and uses the first un-prefixed value as the input, even if that requires skipping over other flags or options.  If ","type":"text"},{"type":"codeVoice","code":"name"},{"type":"text","text":" were defined as "},{"code":"@Option(parsing: .scanningForValue) var name: String","type":"codeVoice"},{"text":", the parser would look ahead to find ","type":"text"},{"code":"Tomás","type":"codeVoice"},{"type":"text","text":", then pick up parsing where it left off to get the "},{"code":"--verbose","type":"codeVoice"},{"text":" flag:","type":"text"}]},{"syntax":null,"code":["% example --name --verbose Tomás","Verbose: true, name: Tomás, file: none"],"type":"codeListing"},{"anchor":"Alternative-array-parsing-strategies","type":"heading","text":"Alternative array parsing strategies","level":3},{"inlineContent":[{"type":"text","text":"The default strategy for parsing options as arrays is to read each value from a key-value pair. For example, this command expects zero or more input file names:"}],"type":"paragraph"},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Option var file: [String] = []","    @Flag var verbose = false","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), files: \\(file)\")","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"As with single values, each time the user provides the ","type":"text"},{"code":"--file","type":"codeVoice"},{"type":"text","text":" key, they must also provide a value:"}]},{"code":["% example --verbose --file file1.swift --file file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --file --verbose file1.swift --file file2.swift","Error: Missing value for '--file <file>'","Usage: example [--file <file> ...] [--verbose]","  See 'example --help' for more information."],"syntax":null,"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"code":".unconditionalSingleValue","type":"codeVoice"},{"type":"text","text":" parsing strategy uses whatever input follows the key as its value, even if that input is dash-prefixed. If "},{"code":"file","type":"codeVoice"},{"type":"text","text":" were defined as "},{"type":"codeVoice","code":"@Option(parsing: .unconditionalSingleValue) var file: [String]"},{"type":"text","text":", then the resulting array could include strings that look like options:"}],"type":"paragraph"},{"syntax":null,"code":["% example --file file1.swift --file --verbose","Verbose: false, files: [\"file1.swift\", \"--verbose\"]"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".upToNextOption"},{"type":"text","text":" parsing strategy uses the inputs that follow the option key until reaching a dash-prefixed input. If "},{"type":"codeVoice","code":"file"},{"type":"text","text":" were defined as "},{"code":"@Option(parsing: .upToNextOption) var file: [String]","type":"codeVoice"},{"text":", then the user could specify multiple files without repeating ","type":"text"},{"type":"codeVoice","code":"--file"},{"text":":","type":"text"}]},{"type":"codeListing","code":["% example --file file1.swift file2.swift","Verbose: false, files: [\"file1.swift\", \"file2.swift\"]","% example --file file1.swift file2.swift --verbose","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]"],"syntax":null},{"inlineContent":[{"type":"text","text":"Finally, the "},{"code":".remaining","type":"codeVoice"},{"text":" parsing strategy uses all the inputs that follow the option key, regardless of their prefix. If ","type":"text"},{"code":"file","type":"codeVoice"},{"text":" were defined as ","type":"text"},{"code":"@Option(parsing: .remaining) var file: [String]","type":"codeVoice"},{"type":"text","text":", then the user would need to specify "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" before the "},{"type":"codeVoice","code":"--file"},{"type":"text","text":" key for it to be recognized as a flag:"}],"type":"paragraph"},{"syntax":null,"code":["% example --verbose --file file1.swift file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --file file1.swift file2.swift --verbose","Verbose: false, files: [\"file1.swift\", \"file2.swift\", \"--verbose\"]"],"type":"codeListing"},{"level":3,"anchor":"Alternative-positional-argument-parsing-strategies","text":"Alternative positional argument parsing strategies","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The default strategy for parsing arrays of positional arguments is to ignore  all dash-prefixed command-line inputs. For example, this command accepts a ","type":"text"},{"code":"--verbose","type":"codeVoice"},{"type":"text","text":" flag and a list of file names as positional arguments:"}]},{"syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    @Argument var files: [String] = []","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), files: \\(files)\")","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"files","type":"codeVoice"},{"text":" argument array uses the default ","type":"text"},{"code":".remaining","type":"codeVoice"},{"text":" parsing strategy, so it only picks up values that don’t have a prefix:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["% example --verbose file1.swift file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --verbose file1.swift file2.swift --other","Error: Unexpected argument '--other'","Usage: example [--verbose] [<files> ...]","  See 'example --help' for more information."],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any input after the "},{"type":"codeVoice","code":"--"},{"text":" terminator is automatically treated as positional input, so users can provide dash-prefixed values that way even with the default configuration:","type":"text"}]},{"syntax":null,"type":"codeListing","code":["% example --verbose -- file1.swift file2.swift --other","Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]"]},{"inlineContent":[{"text":"The ","type":"text"},{"code":".unconditionalRemaining","type":"codeVoice"},{"text":" parsing strategy uses whatever input is left after parsing known options and flags, even if that input is dash-prefixed, including the terminator itself. If ","type":"text"},{"code":"files","type":"codeVoice"},{"type":"text","text":" were defined as "},{"type":"codeVoice","code":"@Argument(parsing: .unconditionalRemaining) var files: [String]"},{"type":"text","text":", then the resulting array would also include strings that look like options:"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["% example --verbose file1.swift file2.swift --other","Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]","% example -- --verbose file1.swift file2.swift --other","Verbose: false, files: [\"--\", \"--verbose\", \"file1.swift\", \"file2.swift\", \"--other\"]"]},{"text":"Ignoring unknown arguments","anchor":"Ignoring-unknown-arguments","type":"heading","level":3},{"inlineContent":[{"text":"Different versions of a CLI tool may have full or partial sets of supported flags and options.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"By default, ","type":"text"},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" throws an error if unknown arguments are passed as command input."},{"type":"text","text":" "},{"type":"text","text":"When appropriate, you can process supported arguments and ignore unknown ones by collecting unknowns in special "},{"code":"@Argument","type":"codeVoice"},{"text":" with the ","type":"text"},{"code":".allUnrecognized","type":"codeVoice"},{"text":" strategy.","type":"text"}]},{"code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    ","    @Argument(parsing: .allUnrecognized)","    var unknowns: [String] = []","","    func run() throws {","        print(\"Verbose: \\(verbose)\")","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This way any unknown parameters are silently captured in the ","type":"text"},{"type":"codeVoice","code":"unknowns"},{"type":"text","text":" array."}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["% example --flag --verbose --option abc file1.swift","Verbose: true"]}]}],"kind":"article","schemaVersion":{"patch":0,"major":0,"minor":3},"sections":[],"identifier":{"url":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/DeclaringArguments","interfaceLanguage":"swift"},"references":{"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/ExpressibleByArgument/init(argument:)":{"type":"topic","required":true,"kind":"symbol","fragments":[{"text":"init","kind":"identifier"},{"text":"?(","kind":"text"},{"kind":"externalParam","text":"argument"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:SS","text":"String"},{"kind":"text","text":")"}],"title":"init(argument:)","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument\/init(argument:)","url":"\/documentation\/argumentparser\/expressiblebyargument\/init(argument:)","role":"symbol","abstract":[{"type":"text","text":"Creates a new instance of this type from a command-line-specified"},{"type":"text","text":" "},{"type":"text","text":"argument."}]},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/Option":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Option","kind":"identifier"}],"navigatorTitle":[{"text":"Option","kind":"identifier"}],"kind":"symbol","abstract":[{"type":"text","text":"A property wrapper that represents a command-line option."}],"role":"symbol","title":"Option","url":"\/documentation\/argumentparser\/option","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Option","type":"topic"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/ParsableArguments":{"url":"\/documentation\/argumentparser\/parsablearguments","navigatorTitle":[{"kind":"identifier","text":"ParsableArguments"}],"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments","role":"symbol","title":"ParsableArguments","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ParsableArguments","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A type that can be parsed from a program’s command-line arguments."}]},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","type":"topic","abstract":[{"text":"Straightforward, type-safe argument parsing for Swift.","type":"text"}],"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser","role":"collection","url":"\/documentation\/argumentparser","kind":"symbol"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/ExpressibleByArgument":{"title":"ExpressibleByArgument","url":"\/documentation\/argumentparser\/expressiblebyargument","role":"symbol","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument","navigatorTitle":[{"text":"ExpressibleByArgument","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A type that can be expressed as a command-line argument."}],"kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ExpressibleByArgument"}]},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/Flag":{"role":"symbol","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Flag","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"Flag"}],"abstract":[{"type":"text","text":"A property wrapper that represents a command-line flag."}],"kind":"symbol","url":"\/documentation\/argumentparser\/flag","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Flag","title":"Flag"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/Validation":{"kind":"article","title":"Providing Custom Validation","url":"\/documentation\/argumentparser\/validation","abstract":[{"type":"text","text":"Provide helpful feedback to users when things go wrong."}],"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Validation","role":"article","type":"topic"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/OptionGroup":{"title":"OptionGroup","abstract":[{"text":"A wrapper that transparently includes a parsable type.","type":"text"}],"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"OptionGroup","kind":"identifier"}],"url":"\/documentation\/argumentparser\/optiongroup","navigatorTitle":[{"kind":"identifier","text":"OptionGroup"}],"type":"topic","role":"symbol","kind":"symbol"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/Argument":{"title":"Argument","abstract":[{"text":"A property wrapper that represents a positional command-line argument.","type":"text"}],"navigatorTitle":[{"text":"Argument","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Argument"}],"type":"topic","role":"symbol","kind":"symbol","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/Argument","url":"\/documentation\/argumentparser\/argument"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/EnumerableFlag":{"abstract":[{"text":"A type that represents the different possible flags to be used by a","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" property."}],"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag","title":"EnumerableFlag","role":"symbol","url":"\/documentation\/argumentparser\/enumerableflag","navigatorTitle":[{"kind":"identifier","text":"EnumerableFlag"}],"type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"EnumerableFlag"}],"kind":"symbol"}}}