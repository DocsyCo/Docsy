{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/argumentparser\/commandsandsubcommands"]}],"sections":[],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","level":2,"anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When command-line programs grow larger, it can be useful to divide them into a group of smaller programs, providing an interface through subcommands. Utilities such as "},{"code":"git","type":"codeVoice"},{"type":"text","text":" and the Swift package manager are able to provide varied interfaces for each of their sub-functions by implementing subcommands such as "},{"code":"git branch","type":"codeVoice"},{"type":"text","text":" or "},{"type":"codeVoice","code":"swift package init"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Generally, these subcommands each have their own configuration options, as well as options that are shared across several or all aspects of the larger program."}]},{"type":"paragraph","inlineContent":[{"text":"You can build a program with commands and subcommands by defining multiple command types and specifying each command’s subcommands in its configuration. For example, here’s the interface of a ","type":"text"},{"type":"codeVoice","code":"math"},{"type":"text","text":" utility that performs operations on a series of values given on the command line."}]},{"type":"codeListing","code":["% math add 10 15 7","32","% math multiply 10 15 7","1050","% math stats average 3 4 13 15 15","10.0","% math stats average --kind median 3 4 13 15 15","13.0","% math stats","OVERVIEW: Calculate descriptive statistics.","","USAGE: math stats <subcommand>","","OPTIONS:","  -h, --help              Show help information.","","SUBCOMMANDS:","  average, avg            Print the average of the values.","  stdev                   Print the standard deviation of the values.","  quantiles               Print the quantiles of the values (TBD).","","  See 'math help stats <subcommand>' for detailed help."],"syntax":null},{"inlineContent":[{"type":"text","text":"Start by defining the root "},{"code":"Math","type":"codeVoice"},{"type":"text","text":" command. You can provide a static "},{"type":"reference","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand\/configuration-35km1","isActive":true},{"type":"text","text":" property for a command that specifies its subcommands and a default subcommand, if any."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Math: ParsableCommand {","    static let configuration = CommandConfiguration(","        abstract: \"A utility for performing maths.\",","        subcommands: [Add.self, Multiply.self, Statistics.self],","        defaultSubcommand: Add.self)","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Math"},{"type":"text","text":" lists its three subcommands by their types; we’ll see the definitions of "},{"type":"codeVoice","code":"Add"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Multiply"},{"type":"text","text":", and "},{"code":"Statistics","type":"codeVoice"},{"text":" below. ","type":"text"},{"type":"codeVoice","code":"Add"},{"type":"text","text":" is also given as a default subcommand — this means that it is selected if a user leaves out a subcommand name:"}]},{"code":["% math 10 15 7","32"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"text":"Next, define a ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments"},{"text":" type with properties that will be shared across multiple subcommands. Types that conform to ","type":"text"},{"type":"codeVoice","code":"ParsableArguments"},{"type":"text","text":" can be parsed from command-line arguments, but don’t provide any execution through a "},{"type":"codeVoice","code":"run()"},{"text":" method.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case, the "},{"code":"Options","type":"codeVoice"},{"text":" type accepts a ","type":"text"},{"code":"--hexadecimal-output","type":"codeVoice"},{"type":"text","text":" flag and expects a list of integers."}]},{"syntax":"swift","type":"codeListing","code":["struct Options: ParsableArguments {","    @Flag(name: [.long, .customShort(\"x\")], help: \"Use hexadecimal notation for the result.\")","    var hexadecimalOutput = false","","    @Argument(help: \"A group of integers to operate on.\")","    var values: [Int]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s time to define our first two subcommands: "},{"type":"codeVoice","code":"Add"},{"type":"text","text":" and "},{"code":"Multiply","type":"codeVoice"},{"type":"text","text":". Both of these subcommands include the arguments defined in the "},{"type":"codeVoice","code":"Options"},{"type":"text","text":" type by denoting that property with the "},{"type":"codeVoice","code":"@OptionGroup"},{"type":"text","text":" property wrapper (see "},{"type":"reference","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","isActive":true},{"text":"). ","type":"text"},{"type":"codeVoice","code":"@OptionGroup"},{"type":"text","text":" doesn’t define any new arguments for a command; instead, it splats in the arguments defined by another "},{"code":"ParsableArguments","type":"codeVoice"},{"type":"text","text":" type."}]},{"type":"codeListing","syntax":"swift","code":["extension Math {","    struct Add: ParsableCommand {","        static let configuration","            = CommandConfiguration(abstract: \"Print the sum of the values.\")","","        @OptionGroup var options: Math.Options","","        mutating func run() {","            let result = options.values.reduce(0, +)","            print(format(result: result, usingHex: options.hexadecimalOutput))","        }","    }","","    struct Multiply: ParsableCommand {","        static let configuration = CommandConfiguration(","            abstract: \"Print the product of the values.\",","            aliases: [\"mul\"])","","        @OptionGroup var options: Math.Options","","        mutating func run() {","            let result = options.values.reduce(1, *)","            print(format(result: result, usingHex: options.hexadecimalOutput))","        }","    }","}"]},{"inlineContent":[{"type":"text","text":"One thing to note is the aliases parameter for "},{"code":"CommandConfiguration","type":"codeVoice"},{"text":". This is useful for subcommands","type":"text"},{"type":"text","text":" "},{"text":"to define alternative names that can be used to invoke them. In this case we’ve defined a shorthand","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"for multiply named mul, so you could invoke the "},{"code":"Multiply","type":"codeVoice"},{"text":" command for our program by either of the below:","type":"text"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["% math multiply 10 15 7","1050","% math mul 10 15 7","1050"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we’ll define "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":", the third subcommand of "},{"code":"Math","type":"codeVoice"},{"type":"text","text":". The "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":" command specifies a custom command name ("},{"type":"codeVoice","code":"stats"},{"type":"text","text":") in its configuration, overriding the default derived from the type name ("},{"type":"codeVoice","code":"statistics"},{"type":"text","text":"). It also declares two additional subcommands, meaning that it acts as a forked branch in the command tree, and not a leaf."}]},{"syntax":"swift","code":["extension Math {","    struct Statistics: ParsableCommand {","        static let configuration = CommandConfiguration(","            commandName: \"stats\",","            abstract: \"Calculate descriptive statistics.\",","            subcommands: [Average.self, StandardDeviation.self])","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Let’s finish our subcommands with the ","type":"text"},{"code":"Average","type":"codeVoice"},{"type":"text","text":" and "},{"code":"StandardDeviation","type":"codeVoice"},{"type":"text","text":" types. Each of them has slightly different arguments, so they don’t use the "},{"code":"Options","type":"codeVoice"},{"type":"text","text":" type defined above. Each subcommand is ultimately independent and can specify a combination of shared and unique arguments."}]},{"code":["extension Math.Statistics {","    struct Average: ParsableCommand {","        static let configuration = CommandConfiguration(","            abstract: \"Print the average of the values.\",","            aliases: [\"avg\"])","","        enum Kind: String, ExpressibleByArgument {","            case mean, median, mode","        }","","        @Option(help: \"The kind of average to provide.\")","        var kind: Kind = .mean","","        @Argument(help: \"A group of floating-point values to operate on.\")","        var values: [Double] = []","","        func calculateMean() -> Double { ... }","        func calculateMedian() -> Double { ... }","        func calculateMode() -> [Double] { ... }","","        mutating func run() {","            switch kind {","            case .mean:","                print(calculateMean())","            case .median:","                print(calculateMedian())","            case .mode:","                let result = calculateMode()","                    .map(String.init(describing:))","                    .joined(separator: \" \")","                print(result)","            }","        }","    }","","    struct StandardDeviation: ParsableCommand {","        static let configuration = CommandConfiguration(","            commandName: \"stdev\",","            abstract: \"Print the standard deviation of the values.\")","","        @Argument(help: \"A group of floating-point values to operate on.\")","        var values: [Double] = []","","        mutating func run() {","            if values.isEmpty {","                print(0.0)","            } else {","                let sum = values.reduce(0, +)","                let mean = sum \/ Double(values.count)","                let squaredErrors = values","                    .map { $0 - mean }","                    .map { $0 * $0 }","                let variance = squaredErrors.reduce(0, +) \/ Double(values.count)","                let result = variance.squareRoot()","                print(result)","            }","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Last but not least, we add the "},{"code":"@main","type":"codeVoice"},{"type":"text","text":" attribute to the root of our command tree, to tell the compiler to use that as the program’s entry point. Upon execution, this parses the command-line arguments, determines whether a subcommand was selected, and then instantiates and calls the "},{"code":"run()","type":"codeVoice"},{"type":"text","text":" method on that particular subcommand."}]},{"name":"Note","style":"note","content":[{"inlineContent":[{"type":"text","text":"The Swift compiler uses either the type marked with "},{"code":"@main","type":"codeVoice"},{"type":"text","text":" or a "},{"type":"codeVoice","code":"main.swift"},{"text":" file as the entry point for an executable program. You can use either one, but not both — rename your ","type":"text"},{"type":"codeVoice","code":"main.swift"},{"type":"text","text":" file to the name of your command when you add "},{"code":"@main","type":"codeVoice"},{"type":"text","text":". In this case, rename it to "},{"type":"codeVoice","code":"Math.swift"},{"text":".","type":"text"}],"type":"paragraph"}],"type":"aside"},{"syntax":"swift","type":"codeListing","code":["@main","struct Math: ParsableCommand {","    \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"text":"That’s it for this doubly-nested ","type":"text"},{"type":"codeVoice","code":"math"},{"text":" command! This example is also provided as a part of the ","type":"text"},{"code":"swift-argument-parser","type":"codeVoice"},{"type":"text","text":" repository, so you can see it all together and experiment with it "},{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/Math.swift","type":"reference"},{"text":".","type":"text"}]}]}],"kind":"article","seeAlsoSections":[{"identifiers":["doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/GettingStarted","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp"],"title":"Essentials","anchor":"Essentials","generated":true}],"metadata":{"title":"Defining Commands and Subcommands","modules":[{"name":"ArgumentParser"}],"roleHeading":"Article","role":"article"},"schemaVersion":{"minor":3,"patch":0,"major":0},"abstract":[{"text":"Break complex command-line tools into a tree of subcommands.","type":"text"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands"},"hierarchy":{"paths":[["doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser"],["doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand"]]},"references":{"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/OptionGroup":{"title":"OptionGroup","abstract":[{"text":"A wrapper that transparently includes a parsable type.","type":"text"}],"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"OptionGroup","kind":"identifier"}],"url":"\/documentation\/argumentparser\/optiongroup","navigatorTitle":[{"kind":"identifier","text":"OptionGroup"}],"type":"topic","role":"symbol","kind":"symbol"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/GettingStarted":{"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/GettingStarted","title":"Getting Started with ArgumentParser","type":"topic","role":"article","abstract":[{"text":"Learn to set up and customize a simple command-line tool.","type":"text"}],"kind":"article","url":"\/documentation\/argumentparser\/gettingstarted"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/AsyncParsableCommand":{"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","url":"\/documentation\/argumentparser\/asyncparsablecommand","type":"topic","abstract":[{"type":"text","text":"A type that can be executed asynchronously, as part of a nested tree of"},{"text":" ","type":"text"},{"text":"commands.","type":"text"}],"fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"AsyncParsableCommand","kind":"identifier"}],"navigatorTitle":[{"text":"AsyncParsableCommand","kind":"identifier"}],"role":"symbol","kind":"symbol","title":"AsyncParsableCommand"},"https://github.com/apple/swift-argument-parser/blob/main/Examples/math/Math.swift":{"titleInlineContent":[{"text":"here","type":"text"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/Math.swift","title":"here","url":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/Math.swift"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/ParsableCommand/configuration-35km1":{"required":true,"abstract":[{"text":"Configuration for this command, including subcommands and custom help","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"text."}],"title":"configuration","kind":"symbol","fragments":[{"text":"static","kind":"keyword"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"text":" ","kind":"text"},{"text":"configuration","kind":"identifier"},{"kind":"text","text":": "},{"text":"CommandConfiguration","preciseIdentifier":"s:14ArgumentParser20CommandConfigurationV","kind":"typeIdentifier"}],"defaultImplementations":1,"role":"symbol","url":"\/documentation\/argumentparser\/parsablecommand\/configuration-35km1","type":"topic","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand\/configuration-35km1"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","type":"topic","abstract":[{"text":"Straightforward, type-safe argument parsing for Swift.","type":"text"}],"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser","role":"collection","url":"\/documentation\/argumentparser","kind":"symbol"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/ParsableArguments":{"url":"\/documentation\/argumentparser\/parsablearguments","navigatorTitle":[{"kind":"identifier","text":"ParsableArguments"}],"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments","role":"symbol","title":"ParsableArguments","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ParsableArguments","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A type that can be parsed from a program’s command-line arguments."}]},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/ParsableCommand":{"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ParsableCommand"}],"abstract":[{"text":"A type that can be executed as part of a nested tree of commands.","type":"text"}],"kind":"symbol","type":"topic","url":"\/documentation\/argumentparser\/parsablecommand","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","navigatorTitle":[{"text":"ParsableCommand","kind":"identifier"}],"role":"symbol","title":"ParsableCommand"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/CustomizingCommandHelp":{"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp","title":"Customizing Help for Commands","kind":"article","abstract":[{"type":"text","text":"Define your command’s abstract, extended discussion, or usage string, and set the flags used to invoke the help display."}],"url":"\/documentation\/argumentparser\/customizingcommandhelp","type":"topic","role":"article"}}}