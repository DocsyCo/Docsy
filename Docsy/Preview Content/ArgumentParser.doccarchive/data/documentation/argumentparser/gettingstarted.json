{"seeAlsoSections":[{"title":"Essentials","generated":true,"identifiers":["doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp"],"anchor":"Essentials"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"kind":"article","hierarchy":{"paths":[["doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser"]]},"sections":[],"metadata":{"role":"article","roleHeading":"Article","title":"Getting Started with ArgumentParser","modules":[{"name":"ArgumentParser"}]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/GettingStarted"},"abstract":[{"type":"text","text":"Learn to set up and customize a simple command-line tool."}],"primaryContentSections":[{"content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"inlineContent":[{"type":"text","text":"This guide walks through building an example command. You’ll learn about the different tools that "},{"code":"ArgumentParser","type":"codeVoice"},{"type":"text","text":" provides for defining a command’s options, customizing the interface, and providing help text for your user."}],"type":"paragraph"},{"text":"Adding ArgumentParser as a Dependency","type":"heading","level":2,"anchor":"Adding-ArgumentParser-as-a-Dependency"},{"type":"paragraph","inlineContent":[{"text":"Let’s write a tool called ","type":"text"},{"code":"count","type":"codeVoice"},{"type":"text","text":" that reads an input file, counts the words, and writes the result to an output file."}]},{"type":"paragraph","inlineContent":[{"text":"First, we need to add ","type":"text"},{"code":"swift-argument-parser","type":"codeVoice"},{"text":" as a dependency to our package,","type":"text"},{"text":" ","type":"text"},{"text":"and then include ","type":"text"},{"type":"codeVoice","code":"\"ArgumentParser\""},{"type":"text","text":" as a dependency for our executable target."},{"type":"text","text":" "},{"type":"text","text":"Our “Package.swift” file ends up looking like this:"}]},{"type":"codeListing","code":["\/\/ swift-tools-version:5.5","import PackageDescription","","let package = Package(","    name: \"Count\",","    dependencies: [","        .package(url: \"https:\/\/github.com\/apple\/swift-argument-parser.git\", from: \"1.3.0\"),","    ],","    targets: [","        .executableTarget(","            name: \"count\",","            dependencies: [.product(name: \"ArgumentParser\", package: \"swift-argument-parser\")]),","    ]",")"],"syntax":"swift"},{"anchor":"Building-Our-First-Command","level":2,"type":"heading","text":"Building Our First Command"},{"inlineContent":[{"type":"text","text":"Once we’ve built the "},{"code":"count","type":"codeVoice"},{"text":" tool, we’ll be able to run it like this:","type":"text"}],"type":"paragraph"},{"code":["% count readme.md readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing","syntax":null},{"inlineContent":[{"type":"text","text":"We’ll define the initial version of the command as a type that conforms to the "},{"code":"ParsableCommand","type":"codeVoice"},{"text":" protocol:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["import ArgumentParser","","@main","struct Count: ParsableCommand {","    @Argument var inputFile: String","    @Argument var outputFile: String","    ","    mutating func run() throws {","        print(\"\"\"","            Counting words in '\\(inputFile)' \\","            and writing the result into '\\(outputFile)'.","            \"\"\")","            ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"]},{"inlineContent":[{"text":"In the code above, the ","type":"text"},{"type":"codeVoice","code":"inputFile"},{"type":"text","text":" and "},{"type":"codeVoice","code":"outputFile"},{"type":"text","text":" properties use the "},{"code":"@Argument","type":"codeVoice"},{"type":"text","text":" property wrapper. "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" uses this wrapper to denote a positional command-line input — because "},{"type":"codeVoice","code":"inputFile"},{"text":" is specified first in the ","type":"text"},{"type":"codeVoice","code":"Count"},{"text":" type, it’s the first value read from the command line, and ","type":"text"},{"type":"codeVoice","code":"outputFile"},{"text":" is the second.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The command’s logic is implemented in its "},{"type":"codeVoice","code":"run()"},{"text":" method. Here, it prints out a message confirming the names of the files the user gave. (You can find a full implementation of the completed command at the end of this guide.)","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Finally, the ","type":"text"},{"code":"Count","type":"codeVoice"},{"type":"text","text":" command is designated as the program’s entry point by applying the "},{"code":"@main","type":"codeVoice"},{"type":"text","text":" attribute. When running your command, the "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" library parses the command-line arguments, verifies that they match up with what we’ve defined in "},{"code":"Count","type":"codeVoice"},{"text":", and either calls the ","type":"text"},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method or exits with a helpful message."}]},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"The Swift compiler uses either the type marked with "},{"code":"@main","type":"codeVoice"},{"type":"text","text":" or a "},{"type":"codeVoice","code":"main.swift"},{"type":"text","text":" file as the entry point for an executable program. You can use either one, but not both — rename your "},{"type":"codeVoice","code":"main.swift"},{"text":" file to the name of the command when you add ","type":"text"},{"code":"@main","type":"codeVoice"},{"type":"text","text":". In this case, rename the file to "},{"code":"Count.swift","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]},{"anchor":"Working-with-Named-Options","text":"Working with Named Options","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"Our ","type":"text"},{"type":"codeVoice","code":"count"},{"type":"text","text":" tool may have a usability problem — it’s not immediately clear whether a user should provide the input file first, or the output file. Instead of using positional arguments for our two inputs, let’s specify that they should be labeled options:"}]},{"code":["% count --input-file readme.md --output-file readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"text":"We do this by using the ","type":"text"},{"type":"codeVoice","code":"@Option"},{"text":" property wrapper instead of ","type":"text"},{"type":"codeVoice","code":"@Argument"},{"text":":","type":"text"}]},{"syntax":"swift","code":["@main","struct Count: ParsableCommand {","    @Option var inputFile: String","    @Option var outputFile: String","    ","    mutating func run() throws {","        print(\"\"\"","            Counting words in '\\(inputFile)' \\","            and writing the result into '\\(outputFile)'.","            \"\"\")","            ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"code":"@Option","type":"codeVoice"},{"text":" property wrapper denotes a command-line input that looks like ","type":"text"},{"type":"codeVoice","code":"--name <value>"},{"type":"text","text":", deriving its name from the name of your property."}],"type":"paragraph"},{"inlineContent":[{"text":"This interface has a trade-off for the users of our ","type":"text"},{"type":"codeVoice","code":"count"},{"type":"text","text":" tool: With "},{"code":"@Argument","type":"codeVoice"},{"text":", users don’t need to type as much, but they have to remember whether to provide the input file or the output file first. Using ","type":"text"},{"type":"codeVoice","code":"@Option"},{"text":" makes the user type a little more, but the distinction between values is explicit. Options are order-independent, as well, so the user can name the input and output files in either order:","type":"text"}],"type":"paragraph"},{"syntax":null,"code":["% count --output-file readme.counts --input-file readme.md","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing"},{"anchor":"Adding-a-Flag","text":"Adding a Flag","level":2,"type":"heading"},{"inlineContent":[{"text":"Next, we want to add a ","type":"text"},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag to our tool, and only print the message if the user specifies that option:"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["% count --input-file readme.md --output-file readme.counts","(no output)","% count --verbose --input-file readme.md --output-file readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."]},{"inlineContent":[{"text":"Let’s change our ","type":"text"},{"type":"codeVoice","code":"Count"},{"type":"text","text":" type to look like this:"}],"type":"paragraph"},{"type":"codeListing","code":["@main","struct Count: ParsableCommand {","    @Option var inputFile: String","    @Option var outputFile: String","    @Flag var verbose = false","    ","    mutating func run() throws {","        if verbose {","            print(\"\"\"","                Counting words in '\\(inputFile)' \\","                and writing the result into '\\(outputFile)'.","                \"\"\")","        }"," ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" property wrapper denotes a command-line input that looks like "},{"type":"codeVoice","code":"--name"},{"text":", deriving its name from the name of your property. Flags are most frequently used for Boolean values, like the ","type":"text"},{"type":"codeVoice","code":"verbose"},{"text":" property here.","type":"text"}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Using-Custom-Names","text":"Using Custom Names"},{"inlineContent":[{"type":"text","text":"We can customize the names of our options and add an alternative to the "},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" flag so that users can specify "},{"type":"codeVoice","code":"-v"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"--verbose"},{"text":". The new interface will look like this:","type":"text"}],"type":"paragraph"},{"code":["% count -v -i readme.md -o readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'.","% count --input readme.md --output readme.counts -v","Counting words in 'readme.md' and writing the result into 'readme.counts'.","% count -o readme.counts -i readme.md --verbose","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"syntax":null,"type":"codeListing"},{"inlineContent":[{"text":"Customize the input names by passing ","type":"text"},{"type":"codeVoice","code":"name"},{"text":" parameters to the ","type":"text"},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" initializers:"}],"type":"paragraph"},{"type":"codeListing","code":["@main","struct Count: ParsableCommand {","    @Option(name: [.short, .customLong(\"input\")])","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")])","    var outputFile: String","","    @Flag(name: .shortAndLong)","    var verbose = false","    ","    mutating func run() throws { ... }","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"The default name specification is "},{"code":".long","type":"codeVoice"},{"type":"text","text":", which uses a property’s name with a two-dash prefix. "},{"code":".short","type":"codeVoice"},{"text":" uses only the first letter of a property’s name with a single-dash prefix, and allows combining groups of short options. You can specify custom short and long names with the ","type":"text"},{"code":".customShort(_:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":".customLong(_:)","type":"codeVoice"},{"text":" methods, respectively, or use the combined ","type":"text"},{"code":".shortAndLong","type":"codeVoice"},{"type":"text","text":" property to specify the common case of both the short and long derived names."}],"type":"paragraph"},{"level":2,"type":"heading","anchor":"Providing-Help","text":"Providing Help"},{"inlineContent":[{"code":"ArgumentParser","type":"codeVoice"},{"type":"text","text":" automatically generates help for any command when a user provides the "},{"code":"-h","type":"codeVoice"},{"type":"text","text":" or "},{"code":"--help","type":"codeVoice"},{"type":"text","text":" flags:"}],"type":"paragraph"},{"code":["% count --help","USAGE: count --input <input> --output <output> [--verbose]","","OPTIONS:","  -i, --input <input>      ","  -o, --output <output>    ","  -v, --verbose            ","  -h, --help              Show help information."],"type":"codeListing","syntax":null},{"inlineContent":[{"text":"This is a great start — you can see that all the custom names are visible, and the help shows that values are expected for the ","type":"text"},{"type":"codeVoice","code":"--input"},{"text":" and ","type":"text"},{"code":"--output","type":"codeVoice"},{"type":"text","text":" options. However, our custom options and flag don’t have any descriptive text. Let’s add that now by passing string literals as the "},{"code":"help","type":"codeVoice"},{"text":" parameter:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["@main","struct Count: ParsableCommand {","    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")","    var outputFile: String","","    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")","    var verbose = false","","    mutating func run() throws { ... }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The help screen now includes descriptions for each parameter:"}]},{"type":"codeListing","syntax":null,"code":["% count -h","USAGE: count --input <input> --output <output> [--verbose]","","OPTIONS:","  -i, --input <input>     A file to read. ","  -o, --output <output>   A file to save word counts to. ","  -v, --verbose           Print status updates while counting. ","  -h, --help              Show help information.",""]},{"level":2,"text":"The Complete Utility","type":"heading","anchor":"The-Complete-Utility"},{"inlineContent":[{"text":"As promised, here’s the complete ","type":"text"},{"code":"count","type":"codeVoice"},{"type":"text","text":" command, for your experimentation:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["import ArgumentParser","import Foundation","","@main","struct Count: ParsableCommand {","    static let configuration = CommandConfiguration(abstract: \"Word counter.\")","    ","    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")","    var outputFile: String","","    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")","    var verbose = false","","    mutating func run() throws {","        if verbose {","            print(\"\"\"","                Counting words in '\\(inputFile)' \\","                and writing the result into '\\(outputFile)'.","                \"\"\")","        }"," ","        guard let input = try? String(contentsOfFile: inputFile) else {","            throw RuntimeError(\"Couldn't read from '\\(inputFile)'!\")","        }","        ","        let words = input.components(separatedBy: .whitespacesAndNewlines)","            .map { word in","                word.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)","                    .lowercased()","            }","            .compactMap { word in word.isEmpty ? nil : word }","        ","        let counts = Dictionary(grouping: words, by: { $0 })","            .mapValues { $0.count }","            .sorted(by: { $0.value > $1.value })","        ","        if verbose {","            print(\"Found \\(counts.count) words.\")","        }","        ","        let output = counts.map { word, count in \"\\(word): \\(count)\" }","            .joined(separator: \"\\n\")","        ","        guard let _ = try? output.write(toFile: outputFile, atomically: true, encoding: .utf8) else {","            throw RuntimeError(\"Couldn't write to '\\(outputFile)'!\")","        }","    }","}","","struct RuntimeError: Error, CustomStringConvertible {","    var description: String","    ","    init(_ description: String) {","        self.description = description","    }","}"]},{"level":2,"type":"heading","text":"Next Steps … Swift concurrency","anchor":"Next-Steps--Swift-concurrency"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ArgumentParser"},{"text":" supports Swift concurrency, notably ","type":"text"},{"code":"async","type":"codeVoice"},{"type":"text","text":" renditions of "},{"type":"codeVoice","code":"run"},{"text":". If you use ","type":"text"},{"code":"async","type":"codeVoice"},{"text":" rendition of ","type":"text"},{"type":"codeVoice","code":"run"},{"type":"text","text":", conform to "},{"type":"codeVoice","code":"AsyncParsableCommand"},{"type":"text","text":" instead of "},{"code":"ParsableCommand","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@main","struct FileUtility: AsyncParsableCommand {","    @Argument(","        help: \"File to be parsed.\",","        transform: URL.init(fileURLWithPath:)","    )","    var file: URL","","    mutating func run() async throws {","        let handle = try FileHandle(forReadingFrom: file)","","        for try await line in handle.bytes.lines {","            \/\/ do something with each line","        }","","        try handle.close()","    }","}"]},{"style":"note","name":"Note","content":[{"inlineContent":[{"text":"If you accidentally use ","type":"text"},{"type":"codeVoice","code":"ParsableCommand"},{"type":"text","text":" with an "},{"type":"codeVoice","code":"async"},{"text":" rendition of ","type":"text"},{"code":"run","type":"codeVoice"},{"type":"text","text":", the app may never reach your "},{"type":"codeVoice","code":"run"},{"type":"text","text":" function and may only show the "},{"code":"USAGE","type":"codeVoice"},{"text":" text. If you are using ","type":"text"},{"type":"codeVoice","code":"async"},{"type":"text","text":" version of "},{"type":"codeVoice","code":"run"},{"text":", you must use ","type":"text"},{"type":"codeVoice","code":"AsyncParsableCommand"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"aside"}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/argumentparser\/gettingstarted"]}],"references":{"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/CommandsAndSubcommands":{"abstract":[{"text":"Break complex command-line tools into a tree of subcommands.","type":"text"}],"title":"Defining Commands and Subcommands","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","url":"\/documentation\/argumentparser\/commandsandsubcommands","role":"article","kind":"article","type":"topic"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/ParsableCommand":{"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ParsableCommand"}],"abstract":[{"text":"A type that can be executed as part of a nested tree of commands.","type":"text"}],"kind":"symbol","type":"topic","url":"\/documentation\/argumentparser\/parsablecommand","identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","navigatorTitle":[{"text":"ParsableCommand","kind":"identifier"}],"role":"symbol","title":"ParsableCommand"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","type":"topic","abstract":[{"text":"Straightforward, type-safe argument parsing for Swift.","type":"text"}],"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser","role":"collection","url":"\/documentation\/argumentparser","kind":"symbol"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/CustomizingCommandHelp":{"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp","title":"Customizing Help for Commands","kind":"article","abstract":[{"type":"text","text":"Define your command’s abstract, extended discussion, or usage string, and set the flags used to invoke the help display."}],"url":"\/documentation\/argumentparser\/customizingcommandhelp","type":"topic","role":"article"},"doc://swift-argument-parser.ArgumentParser/documentation/ArgumentParser/AsyncParsableCommand":{"identifier":"doc:\/\/swift-argument-parser.ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","url":"\/documentation\/argumentparser\/asyncparsablecommand","type":"topic","abstract":[{"type":"text","text":"A type that can be executed asynchronously, as part of a nested tree of"},{"text":" ","type":"text"},{"text":"commands.","type":"text"}],"fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"AsyncParsableCommand","kind":"identifier"}],"navigatorTitle":[{"text":"AsyncParsableCommand","kind":"identifier"}],"role":"symbol","kind":"symbol","title":"AsyncParsableCommand"}}}